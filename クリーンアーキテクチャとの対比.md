# 第III部 パラダイムと第III部 設計原則とあなたのシステム

## 第3章〜第6章：パラダイム（構造化/OOP/関数型）

- **構造化プログラミング / 機能分割**
  - あなたのシステムでは、  
    - 「画像処理 → GeoJSON 出力（OpenCV, rasterio）」  
    - 「ポリゴン属性編集（PyQt5, streamlit）」  
    - 「リスク計算（geopandas, shapely）」  
    といった**処理単位ごとの分割**はすでにできている。
  - ただし、**「処理の順番でしか結合していない」部分**があるなら、  
    クリーンアーキテクチャ的には **ユースケース単位の分割** に昇華させる余地がある。

- **オブジェクト指向プログラミング（カプセル化/継承/ポリモーフィズム）**
  - 現状：
    - `RiskSegment`, `ObservationPoint`, `RiskScore` などの**ドメインオブジェクト**が  
      明示的なクラスとして整理されていれば、すでに **Entities 層** に近い。
    - もし `geopandas.GeoDataFrame` や `shapely.geometry` をそのまま「ドメイン」として扱っているなら、  
      **ライブラリ型にドメインが引きずられている状態**。
  - 再構成ポイント：
    - `class RiskSegment: geometry: PolygonLike, risk_score: float, ...` のように  
      **ドメインクラスを自前で定義**し、`shapely` はアダプタ層に押し出すと  
      クリーンアーキテクチャの「エンティティ」に近づく。

- **関数型プログラミング / 不変性**
  - リスク計算やバリデーションは、  
    - 「入力 → 出力」が明確な**純粋関数**として書ける部分が多い。
  - ここを意識して、
    - `compute_risk_score(segment, hazard_layers) -> RiskScore`
    - `validate_geometry(segment) -> ValidationResult`
    のように **副作用を持たない関数**として切り出すと、  
    クリーンアーキテクチャの「テストしやすいユースケース」に直結する。

---

## 第7章〜第11章：SOLID 原則とあなたのシステム

### SRP：単一責任の原則

- 典型的なアンチパターン：
  - 「GeoJSON を読む + shapely で演算 + MongoDB に保存 + QGIS 用に書き出す」を  
    1 つの関数 / モジュールでやっている。
- あなたのシステムでの再構成：
  - `import_geojson.py`（I/O）
  - `geometry_operations.py`（shapely/geopandas）
  - `risk_calculation.py`（ドメインロジック）
  - `persistence_mongo.py`（MongoDB）
  - `export_qgis.py`（QGIS 用フォーマット変換）
  に分けると、**責務が明確になり、クリーンアーキテクチャの各層にマッピングしやすくなる**。

### OCP：オープン・クローズドの原則

- 例：リスクスコアの計算方法を追加したい（セルベース → ポリゴンベース → 時系列ベース）。
- 現状：
  - `if method == "cell": ... elif method == "polygon": ...` のような分岐が 1 箇所に集中しているなら、  
    **OCP 違反気味**。
- 再構成：
  - `RiskCalculator` インターフェースを定義し、
    - `CellBasedRiskCalculator`
    - `PolygonBasedRiskCalculator`
  - を実装クラスとして分けると、  
    **新しい計算方法を追加しても既存コードをほぼ変更せずに済む**。

### DIP：依存関係逆転の原則

- 現状の依存：
  - ドメインロジックが `geopandas`, `shapely`, `MongoDB`, `FastAPI` に直接依存している部分があれば、  
    クリーンアーキテクチャ的には **再構成ポイント**。
- あるべき姿：
  - ドメイン層は
    - `GeometryService`
    - `RiskSegmentRepository`
    - `ObservationPointRepository`
  - のような **抽象インターフェース** に依存し、
  - 具体実装として
    - `ShapelyGeometryService`
    - `MongoRiskSegmentRepository`
    - `GeoPandasObservationPointRepository`
  - が **外側の層に存在する**。
- ここができると、
  - 「MongoDB → PostGIS に変えたい」
  - 「geopandas → pyogrio ベースに変えたい」
  といった変更が **アダプタ層だけで完結**する。


# 第IV部 コンポーネントの原則とあなたのシステム

## 第13章：コンポーネントの凝集性（REP/CCP/CRP）

- 現状の構成が例えば：
  - `image_processing/`
  - `risk_segment_editor/`
  - `risk_calculator/`
  - `mongo_io/`
  - `qgis_viewer/`
  のように分かれているなら、すでに **コンポーネント単位の凝集**はある程度できている。
- 再構成の観点：
  - **再利用・リリース等価の原則（REP）**
    - 「リスク計算ロジックだけを別プロジェクトでも使いたい」  
      → `risk_core/` のような **ドメイン＋ユースケースだけのパッケージ**を切り出す価値が高い。
  - **閉鎖性共通の原則（CCP）**
    - 「仕様変更が入るとき、いつも同じファイル群が変わる」  
      → それらを 1 コンポーネントにまとめると、変更の影響範囲を局所化できる。

## 第14章：コンポーネントの結合（ADP/SDP/SAP）

- 非循環依存関係の原則（ADP）
  - `risk_calculator` → `mongo_io` → `risk_calculator` のような循環があると、  
    デプロイもテストも壊れやすい。
  - クリーンアーキテクチャでは、
    - `domain/`（エンティティ）
    - `usecases/`
    - `adapters/`
    - `frameworks/`
    のように **一方向の依存グラフ**を作ることで ADP を満たす。
- 安定依存の原則（SDP）
  - `domain/` は最も安定（ほとんど変わらない）  
  - `frameworks/`（FastAPI, streamlit, PyQt5, QGIS）は最も不安定（変わりやすい）
  - 依存方向が
    - `frameworks → adapters → usecases → domain`
    になっていれば、**安定したものに向かって依存している**状態になり、クリーンアーキテクチャの理想に近い。

---

# 第V部 アーキテクチャとあなたのシステム（1）

## 第15章〜第16章：アーキテクチャとは？／独立性

- あなたのシステムはすでに：
  - 画像処理（OpenCV, rasterio）
  - ベクタ処理（geopandas, shapely）
  - UI（PyQt5, streamlit, QGIS）
  - API（FastAPI）
  - DB（MongoDB）
  が**ゆるく分かれた形**になっている。
- クリーンアーキテクチャ的な「独立性」を高めるには：
  - **ユースケース単位で切り離す**
    - 例：`ComputeRiskScoresUseCase` は  
      - 画像処理がどこで行われたか  
      - MongoDB か PostGIS か  
      - QGIS か Web か  
      を知らなくてよい。
  - これにより、
    - 「QGIS プラグイン版」
    - 「Web ダッシュボード版（streamlit）」
    - 「バッチ処理版（CLI）」
    を**同じユースケース層の上に載せ替えられる**。

## 第17章〜第18章：バウンダリー／境界の解剖学

- あなたの図でいうと、すでに境界候補が見えている：
  - **外部世界**
    - 画像処理からの GeoJSON
    - PDF/TIFF/PNG（Document Intelligence）
    - QGIS viewer
    - FastAPI 経由のクライアント
  - **内部世界**
    - リスクセグメント編集
    - リスク計算
    - バリデーション
    - MongoDB への保存
- クリーンアーキテクチャ的には：
  - 「外部世界」と「内部世界」の間に **インターフェース（ポート）** を置く。
    - `GeoJsonInputPort`
    - `DocumentIntelligencePort`
    - `RiskMapOutputPort`
    - `PointScoreInputPort`
  - それぞれの実装として
    - `FastApiGeoJsonController`
    - `AzureFormRecognizerAdapter`
    - `QgisLayerExporter`
    などを **プラグイン的に差し込む**。
- これにより、
  - 「Document Intelligence を Azure → AWS に変える」
  - 「QGIS → Web マップに変える」
  といった変更が **境界の外側だけで完結**する。


# 第V部 アーキテクチャとあなたのシステム（2）

## 第20章：ビジネスルール（エンティティ／ユースケース）

- あなたのシステムのビジネスルールは非常に明確：
  - **エンティティ**
    - `RiskSegment`
    - `ObservationPoint`
    - `RiskScore`
    - `HazardLayer`
    - `CrossSection`
    - `ValidationResult`
  - **ユースケース**
    - 画像処理結果 GeoJSON の取り込み
    - ポリゴン属性編集（AE）
    - 点と面の空間演算
    - リスクスコア計算（セル/ポリゴン）
    - Cross section 生成
    - バリデーション
    - QGIS/画像/GeoJSON への出力
- クリーンアーキテクチャ的評価：
  - すでに「エンティティ」と「ユースケース」は頭の中と概念図では分かれている。  
  - 再構成すべきは：
    - **コード上でもその分離を明示すること**  
      - `domain/entities/*.py`
      - `usecases/*.py`
      - `adapters/*.py`
      - `frameworks/*.py`
    - これができると、本書の第20章がそのままあなたのシステムの設計図になる。

## 第21章：叫ぶアーキテクチャ

- 「アーキテクチャは何について叫んでいるか？」
  - あなたのシステムは、本来：
    - 「防災リスク評価」
    - 「危険エリアの定量化」
    - 「点と面のバリデーション」
    を叫ぶべき。
- もし現状のコードが：
  - `fastapi_app.py`
  - `mongo_models.py`
  - `qgis_plugin.py`
  のように **フレームワーク名やツール名を叫んでいる** 状態なら、  
  クリーンアーキテクチャ的には **再構成ポイント**。
- あるべき姿：
  - `compute_risk_scores.py`
  - `generate_risk_maps.py`
  - `validate_geometries.py`
  のように、**ユースケース名が前面に出る構成**。  
  その上に FastAPI / QGIS / streamlit が「乗っている」だけ、という形が理想。

## 第22章：クリーンアーキテクチャ（依存性のルール）

- 依存性のルール：
  - 内側の層（エンティティ・ユースケース）は外側（フレームワーク・DB・UI）を知らない。
- あなたのシステムでのマッピング：
  - **内側**
    - `domain/`（RiskSegment, ObservationPoint, RiskScore, …）
    - `usecases/`（ImportGeoJson, ComputeRiskScores, GenerateRiskMaps, ValidateData, …）
  - **中間（アダプタ）**
    - `adapters/`
      - `mongo_risk_segment_repository.py`
      - `shapely_geometry_service.py`
      - `rasterio_hazard_layer_loader.py`
      - `qgis_layer_exporter.py`
      - `streamlit_ui_adapter.py`
  - **外側（詳細）**
    - `frameworks/`
      - `fastapi_app.py`
      - `qgis_plugin_entry.py`
      - `cli_main.py`
- 評価：
  - 概念図レベルではすでにこの構造にかなり近い。  
  - コードレベルで **依存方向を一方向に揃える** ことが、  
    「社会で使われる防災システム」にするための決定打になる。

---

# 第VI部 詳細：DB／Web／フレームワークは「詳細」

## 第30章：データベースは詳細（MongoDB）

- 現状：
  - 「MongoDB にどう保存するか」がロジックと混ざっている部分があれば、  
    クリーンアーキテクチャ的には **改善余地あり**。
- あるべき姿：
  - ドメイン側は `RiskSegmentRepository` インターフェースだけを知る。
  - MongoDB への保存は `MongoRiskSegmentRepository` が担当し、  
    これは **アダプタ層の詳細**として扱う。
- これにより：
  - 将来「PostGIS にも保存したい」「ファイルベースにも出したい」となったとき、  
    ドメイン・ユースケース層は一切変更不要になる。

## 第31章：ウェブは詳細（FastAPI, streamlit）

- FastAPI / streamlit は：
  - 「どうリクエストを受けるか」
  - 「どうレスポンスを返すか」
  を担当するだけの **I/O の詳細**。
- 再構成のポイント：
  - FastAPI のエンドポイント内で geospatial ロジックを書かず、
    - `usecases.compute_risk_scores(request_model)`
    - `usecases.generate_risk_maps(request_model)`
    を呼ぶだけにする。
  - streamlit も同様に、**ユースケース層の呼び出しに徹する UI** にする。

## 第32章：フレームワークは詳細（QGIS, PyQt5, OpenCV, matplotlib）

- QGIS プラグイン、PyQt5 GUI、OpenCV 画像処理、matplotlib 可視化はすべて：
  - 「どう見せるか」「どう操作させるか」の詳細。
- 評価：
  - あなたの図では、これらはすでに「周辺」に配置されている。  
  - クリーンアーキテクチャ的には、
    - それらを **adapters/frameworks 層に閉じ込める** ことで、  
      コアロジック（防災リスク評価）がフレームワークから独立した「長寿命な資産」になる。

---

## 総評

- あなたのシステムは、概念図レベルでは **すでにクリーンアーキテクチャの骨格にかなり近い**。
- 再構成すべき主なポイントは：
  - ドメイン（エンティティ）とライブラリ型（geopandas, shapely, rasterio）を分離すること
  - ユースケースを明示的なモジュール／クラスとして切り出すこと
  - MongoDB / FastAPI / QGIS / streamlit を「詳細」として外側に追いやること
- これができれば、  
  **「防災リスク評価」というビジネスルールを中心に据えた、長期運用可能な社会インフラ級システム**  
  として成立します。